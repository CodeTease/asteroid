<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K·∫ª H·ªßy Di·ªát Ti·ªÉu H√†nh Tinh</title>
    <link rel="icon" type="image/png" href="https://ik.imagekit.io/irammini/Teaserverse_icon?updatedAt=1756019938040">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00e5ff;
            --background-color: #030411;
            --text-color: #ffffff;
            --secondary-color: #e500ff;
            --hud-color: #00ffff;
            --danger-color: #ff4500;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Background Effects */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            pointer-events: none;
            z-index: -2;
        }

        .stars::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 1px, transparent 1.5px);
            background-size: 50px 50px;
            animation: move-stars 100s linear infinite;
            transform-origin: 0 0;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0) 0px,
                rgba(0, 0, 0, 0) 2px,
                rgba(0, 229, 255, 0.1) 3px,
                rgba(0, 229, 255, 0.1) 4px
            );
            z-index: 20;
            animation: scanline-flicker 15s linear infinite;
        }

        @keyframes scanline-flicker {
            0% { opacity: 0.8; }
            5% { opacity: 0.6; }
            10% { opacity: 0.8; }
            50% { opacity: 0.8; }
            52% { opacity: 0.9; }
            55% { opacity: 0.7; }
            100% { opacity: 0.8; }
        }

        @keyframes move-stars {
            from { transform: translate(0, 0); }
            to { transform: translate(-50%, -50%); }
        }

        /* Base Panel Styles */
        .panel {
            background: rgba(10, 20, 50, 0.5);
            border: 1px solid var(--primary-color);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.5), inset 0 0 10px rgba(0, 229, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 2;
            padding: 2rem;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .container {
            text-align: center;
            padding: 2rem;
            transition: opacity 1s ease, transform 1s ease;
        }

        .container.hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px var(--primary-color), 0 0 30px var(--primary-color);
            animation: pulse-glow 2s infinite alternate;
        }

        @keyframes pulse-glow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px var(--primary-color), 0 0 30px var(--primary-color); }
            to { text-shadow: 0 0 15px #fff, 0 0 25px var(--primary-color), 0 0 45px var(--primary-color); }
        }

        p {
            font-size: 1.2rem;
            margin: 1rem 0;
        }

        /* Base Button Styles */
        button {
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            border: 1px solid var(--primary-color);
            background-color: transparent;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: inset 0 0 10px rgba(0, 229, 255, 0.5);
            transition: all 0.3s ease;
        }

        button:hover:not(:disabled) {
            background-color: var(--primary-color);
            color: var(--background-color);
            box-shadow: 0 0 15px var(--primary-color), 0 0 25px var(--primary-color);
        }

        button:disabled {
            border-color: #555;
            color: #777;
            cursor: not-allowed;
            box-shadow: none;
            background-color: rgba(30, 30, 30, 0.5);
        }

        .menu-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .menu-buttons button {
            margin-top: 0;
        }


        #play-button {
            border-color: var(--secondary-color);
            box-shadow: inset 0 0 10px rgba(229, 0, 255, 0.5);
        }

        #play-button:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color), 0 0 25px var(--secondary-color);
        }

        /* Credits & Disclaimer */
        .credits {
            margin-top: 3rem;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        .credits p {
            margin: 0.5rem 0;
        }
        .credits a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .credits a:hover {
            color: #fff;
            text-shadow: 0 0 5px var(--primary-color);
        }
        #development-disclaimer {
            margin-top: 1.5rem;
            font-size: 0.8rem;
            font-style: italic;
            opacity: 0.5;
        }


        /* Loading Screen */
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background-color);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .loading-container.visible {
            opacity: 1;
            pointer-events: all;
        }

        .loading-container p {
            font-size: 1.5rem;
            margin-top: 2rem;
            text-shadow: 0 0 10px var(--primary-color);
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(0, 229, 255, 0.2);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }


        /* Game Area & HUD */
        .game-area {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .game-area.visible {
            opacity: 1;
            pointer-events: all;
        }

        canvas {
            border: 1px solid var(--primary-color);
            background-color: transparent;
            box-shadow: 0 0 15px var(--primary-color);
            max-width: 100vw;
            transition: width 1s ease-in-out, height 1s ease-in-out;
        }

        .divider-line { display: none; }

        .hud-panel {
            width: 600px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--hud-color);
            border-top: none;
            box-shadow: 0 0 15px var(--hud-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            box-sizing: border-box;
            transition: width 1s ease;
        }

        .hud-item {
            font-size: 1.1rem;
            text-shadow: 0 0 5px var(--hud-color);
        }

        #game-status {
            transition: opacity 1.5s ease-out;
        }

        .hud-group {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        /* Fullscreen Game State */
        .game-area.fullscreen-game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            z-index: 5;
            flex-direction: column-reverse;
        }

        .game-area.fullscreen-game canvas {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            border: none;
            box-shadow: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 6;
        }

        .game-area.fullscreen-game .hud-panel {
            width: 100vw;
            height: 50px;
            border-radius: 0;
            border: none;
            border-top: 1px solid var(--hud-color);
            box-shadow: 0 0 15px var(--hud-color);
            position: relative;
            z-index: 7;
            background: rgba(3, 4, 17, 0.8);
            backdrop-filter: blur(5px);
        }

        /* Modals */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.7);
            background-color: rgba(10, 10, 42, 0.7);
            backdrop-filter: blur(10px);
            padding: 2.5rem;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 30px var(--primary-color);
            text-align: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            width: 90%;
            max-width: 500px;
        }

        .message-box.visible {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }

        .message-box h2 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 2.5rem;
            text-shadow: 0 0 10px var(--primary-color);
        }

        .message-box p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }

        .message-box .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .message-box .button-group button {
            margin-top: 0;
        }


        .message-box button#message-button, .message-box button#continue-button, .message-box button#back-to-menu-button, #close-how-to-play-button {
            border-color: var(--secondary-color);
            box-shadow: inset 0 0 10px rgba(229, 0, 255, 0.5);
        }
        .message-box button#message-button:hover, .message-box button#continue-button:hover, .message-box button#back-to-menu-button:hover, #close-how-to-play-button:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color), 0 0 25px var(--secondary-color);
        }

        .unselectable {
            user-select: none;
        }

        /* Upgrade Modal */
        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin: 2rem 0;
            text-align: left;
            max-height: 50vh;
            overflow-y: auto;
        }

        .upgrade-category h3 {
            margin: 0 0 0.5rem 0;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--primary-color);
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .upgrade-category button {
            width: 100%;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        .auto-upgrade-container {
            margin-top: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        /* How to Play Modal */
        .how-to-play-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            text-align: left;
            margin-bottom: 2rem;
        }
        .how-to-play-item {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .how-to-play-item p {
            font-size: 1rem;
            margin: 0;
            flex: 1;
        }
        .how-to-play-icon {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }
        .icon-player {
            background-color: #cccccc;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            width: 30px;
            height: 40px;
        }
        .icon-enemy {
            background-color: #a9a9a9;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        .icon-ally {
            background-color: #007bff;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            transform: scale(0.8);
        }


        /* Final Boss Health Bar */
        #final-boss-health-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            height: 25px;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid var(--danger-color);
            border-radius: 10px;
            display: none;
            z-index: 6;
            padding: 2px;
        }
        #final-boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--secondary-color), var(--danger-color));
            border-radius: 8px;
            transition: width 0.2s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="stars"></div>
    <div class="scanlines"></div>

    <div class="container" id="main-container">
        <h1>K·∫ª H·ªßy Di·ªát Ti·ªÉu H√†nh Tinh</h1>
        <p>Ti√™u di·ªát t·∫•t c·∫£ ti·ªÉu h√†nh tinh v√† s·ªëng s√≥t l√¢u nh·∫•t c√≥ th·ªÉ!</p>
        <div class="menu-buttons">
            <button id="play-button">Ch∆°i ngay!</button>
            <button id="how-to-play-button">H∆∞·ªõng d·∫´n</button>
        </div>
        <div class="credits">
            <p>Powered by <a href="https://teaserverse.qzz.io/" target="_blank" rel="noopener noreferrer">Teaserverse</a></p>
            <p>Sound effects from <a href="https://freesound.org/" target="_blank" rel="noopener noreferrer">Freesound.org</a></p>
        </div>
        <p id="development-disclaimer">L∆∞u √Ω: Tr√≤ ch∆°i ƒëang trong giai ƒëo·∫°n ph√°t tri·ªÉn. √Çm thanh v√† t√≠nh nƒÉng c√≥ th·ªÉ ch∆∞a ho√†n thi·ªán.</p>
    </div>
    
    <div id="loading-container" class="loading-container">
        <div class="loader"></div>
        <p>ƒêang t·∫£i t√†i nguy√™n...</p>
    </div>

    <div class="game-area" id="game-area">
        <div id="final-boss-health-container">
            <div id="final-boss-health-bar"></div>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="divider-line"></div>
        <div class="hud-panel unselectable">
            <div class="hud-group">
                <span class="hud-item">üåü <span id="score">0</span></span>
                <span class="hud-item">üõ°Ô∏è <span id="shields">0</span></span>
                <span class="hud-item">üí† <span id="upgrade-points">0</span></span>
            </div>
            <div class="hud-group">
                <span class="hud-item" id="game-status">S·∫µn s√†ng</span>
            </div>
            <div class="hud-group">
                <span class="hud-item">‚è±Ô∏è <span id="timer">0s</span></span>
            </div>
        </div>
    </div>
    
    <div id="message-box" class="message-box unselectable">
        <h2 id="message-title"></h2>
        <p id="message-text"></p>
        <div class="button-group">
            <button id="message-button">Ch∆°i L·∫°i</button>
            <button id="back-to-menu-button">V·ªÅ Menu</button>
        </div>
    </div>

    <div id="upgrade-modal" class="message-box unselectable">
        <h2 id="upgrade-title">N√¢ng c·∫•p!</h2>
        <p>B·∫°n c√≥ <span id="upgrade-points-count">0</span> ƒëi·ªÉm n√¢ng c·∫•p. üí†</p>
        <div class="upgrade-options">
             <div class="upgrade-category">
                <h3>ƒê·ªìng minh th∆∞·ªùng</h3>
                <button id="upgrade-firerate" data-cost="1">B·∫Øn Nhanh H∆°n (<span id="firerate-level">0/5</span>)</button>
                <button id="upgrade-doubleshot" data-cost="1">B·∫Øn G·∫•p ƒê√¥i</button>
                <button id="upgrade-projectilespeed" data-cost="1">ƒê·∫°n Ch√≠nh X√°c H∆°n</button>
            </div>
            <div class="upgrade-category" id="laser-ally-upgrades" style="display: none;">
                <h3>ƒê·ªìng minh Laser</h3>
                <button id="upgrade-laser-damage" data-cost="3">TƒÉng S√°t Th∆∞∆°ng Laser (<span id="laser-damage-level">0/5</span>)</button>
                <button id="upgrade-laser-cooldown" data-cost="4">Gi·∫£m H·ªìi Chi√™u Laser (<span id="laser-cooldown-level">0/5</span>)</button>
            </div>
        </div>
        <div class="auto-upgrade-container">
            <input type="checkbox" id="auto-upgrade-checkbox">
            <label for="auto-upgrade-checkbox">T·ª± ƒë·ªông n√¢ng c·∫•p</label>
        </div>
        <button id="continue-button">Ti·∫øp T·ª•c</button>
    </div>

    <div id="how-to-play-modal" class="message-box unselectable">
        <h2>H∆∞·ªõng d·∫´n</h2>
        <div class="how-to-play-content">
            <div class="how-to-play-item">
                <div class="how-to-play-icon icon-player"></div>
                <p><strong>B·∫°n:</strong> Di chuy·ªÉn b·∫±ng ph√≠m m≈©i t√™n ho·∫∑c k√©o th·∫£ tr√™n m√†n h√¨nh. B·∫Øn t·ª± ƒë·ªông khi nh·∫•n gi·ªØ chu·ªôt/ch·∫°m.</p>
            </div>
            <div class="how-to-play-item">
                <div class="how-to-play-icon icon-enemy"></div>
                <p><strong>K·∫ª ƒë·ªãch:</strong> Ti√™u di·ªát c√°c ti·ªÉu h√†nh tinh ƒë·ªÉ ghi ƒëi·ªÉm. C·∫©n th·∫≠n v·ªõi nh·ªØng lo·∫°i ƒë·∫∑c bi·ªát!</p>
            </div>
            <div class="how-to-play-item">
                <div class="how-to-play-icon icon-ally"></div>
                <p><strong>ƒê·ªìng minh:</strong> ƒê·∫°t m·ªëc ƒëi·ªÉm cao ƒë·ªÉ tri·ªáu h·ªìi c√°c ƒë·ªìng minh AI h·ªó tr·ª£ b·∫°n trong tr·∫≠n chi·∫øn.</p>
            </div>
        </div>
        <button id="close-how-to-play-button">ƒê√£ hi·ªÉu</button>
    </div>

    <script>
    (function() {
        'use strict';

        // --- Start of src/ui.js ---
        const UI = {};
        (function(exports) {
            exports.canvas = document.getElementById('gameCanvas');
            exports.ctx = exports.canvas.getContext('2d');
            exports.messageBox = document.getElementById('message-box');
            exports.messageTitle = document.getElementById('message-title');
            exports.messageText = document.getElementById('message-text');
            exports.messageButton = document.getElementById('message-button');
            exports.backToMenuButton = document.getElementById('back-to-menu-button');
            exports.playButton = document.getElementById('play-button');
            exports.howToPlayButton = document.getElementById('how-to-play-button');
            exports.mainContainer = document.getElementById('main-container');
            exports.loadingContainer = document.getElementById('loading-container');
            exports.gameArea = document.getElementById('game-area');
            exports.scoreDisplay = document.getElementById('score');
            exports.shieldDisplay = document.getElementById('shields');
            exports.gameStatus = document.getElementById('game-status');
            exports.timerDisplay = document.getElementById('timer');
            exports.upgradePointsDisplay = document.getElementById('upgrade-points');
            exports.upgradeModal = document.getElementById('upgrade-modal');
            exports.upgradePointsCount = document.getElementById('upgrade-points-count');
            exports.upgradeFirerateBtn = document.getElementById('upgrade-firerate');
            exports.upgradeDoubleshotBtn = document.getElementById('upgrade-doubleshot');
            exports.upgradeProjectilespeedBtn = document.getElementById('upgrade-projectilespeed');
            exports.firerateLevelDisplay = document.getElementById('firerate-level');
            exports.continueButton = document.getElementById('continue-button');
            exports.autoUpgradeCheckbox = document.getElementById('auto-upgrade-checkbox');
            exports.finalBossHealthContainer = document.getElementById('final-boss-health-container');
            exports.finalBossHealthBar = document.getElementById('final-boss-health-bar');
            exports.laserAllyUpgradesContainer = document.getElementById('laser-ally-upgrades');
            exports.upgradeLaserDamageBtn = document.getElementById('upgrade-laser-damage');
            exports.upgradeLaserCooldownBtn = document.getElementById('upgrade-laser-cooldown');
            exports.laserDamageLevelDisplay = document.getElementById('laser-damage-level');
            exports.laserCooldownLevelDisplay = document.getElementById('laser-cooldown-level');
            exports.howToPlayModal = document.getElementById('how-to-play-modal');
            exports.closeHowToPlayButton = document.getElementById('close-how-to-play-button');


            exports.showMessage = function(title, text) {
                exports.gameStatus.innerText = title;
                exports.messageTitle.innerText = title;
                exports.messageText.innerText = text;
                exports.messageBox.classList.add('visible');
            }

            exports.hideMessage = function(onHiddenCallback) {
                exports.messageBox.classList.remove('visible');
                setTimeout(onHiddenCallback, 300);
            }

            exports.updateUpgradePoints = function(points) {
                exports.upgradePointsDisplay.innerText = `${points}`;
                exports.upgradePointsCount.innerText = `${points}`;
            }

            exports.updateUpgradeModal = function(points, upgrades, hasLaserAlly) {
                exports.updateUpgradePoints(points);
                exports.firerateLevelDisplay.innerText = `${upgrades.fireRateLevel}/5`;

                exports.upgradeFirerateBtn.disabled = points < 1 || upgrades.fireRateLevel >= 5;
                exports.upgradeDoubleshotBtn.disabled = points < 1 || upgrades.hasDoubleShot;
                exports.upgradeProjectilespeedBtn.disabled = points < 1 || upgrades.hasFasterProjectiles;

                exports.upgradeDoubleshotBtn.innerText = upgrades.hasDoubleShot ? "ƒê√£ N√¢ng C·∫•p" : "B·∫Øn G·∫•p ƒê√¥i";
                exports.upgradeProjectilespeedBtn.innerText = upgrades.hasFasterProjectiles ? "ƒê√£ N√¢ng C·∫•p" : "ƒê·∫°n Ch√≠nh X√°c H∆°n";

                if (hasLaserAlly) {
                    exports.laserAllyUpgradesContainer.style.display = 'block';
                    exports.laserDamageLevelDisplay.innerText = `${upgrades.laserDamageLevel}/5`;
                    exports.laserCooldownLevelDisplay.innerText = `${upgrades.laserCooldownLevel}/5`;
                    exports.upgradeLaserDamageBtn.disabled = points < 3 || upgrades.laserDamageLevel >= 5;
                    exports.upgradeLaserCooldownBtn.disabled = points < 4 || upgrades.laserCooldownLevel >= 5;
                } else {
                    exports.laserAllyUpgradesContainer.style.display = 'none';
                }
            }
        })(UI);
        // --- End of src/ui.js ---


        // --- Start of src/audio.js ---
        class AudioManager {
            audioContext = null;
            decodedBuffers = {};
            activeLoopingSources = {};
            isMuted = false;
            isGameSoundsInitialized = false;
            isMenuMusicInitialized = false;

            soundSources = {
                'menuMusic': 'https://ik.imagekit.io/irammini/sounds/menuMusic.mp3',
                'shoot': 'https://ik.imagekit.io/irammini/sounds/shoot.mp3',
                'enemyShoot': 'https://ik.imagekit.io/irammini/sounds/enemyShoot.mp3',
                'finalbossExplosion': 'https://ik.imagekit.io/irammini/sounds/finalbossExplosion.mp3',
                'AIupgraded': 'https://ik.imagekit.io/irammini/sounds/AIupgraded.mp3',
                'enemyDefeated': 'https://ik.imagekit.io/irammini/sounds/enemyDefeated.mp3',
                'finalbossBegin': 'https://ik.imagekit.io/irammini/sounds/finalbossBegin.mp3',
                'finalbossWarning': 'https://ik.imagekit.io/irammini/sounds/finalbossWarning.mp3',
                'laseringSound': 'https://ik.imagekit.io/irammini/sounds/laseringSound.mp3',
                'PlayerDead': 'https://ik.imagekit.io/irammini/sounds/PlayerDead.mp3',
                'Playerupgraded': 'https://ik.imagekit.io/irammini/sounds/Playerupgraded.mp3',
            };

            constructor() {}

            async initAudioContext() {
                if (this.audioContext) {
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    return;
                }
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Web Audio API is not supported in this browser', e);
                    alert('Web Audio API is not supported in this browser. Sound will not work.');
                }
            }

            async initializeAfterInteraction() {
                await this.initAudioContext();
            }

            async initMenuMusic() {
                if (this.isMenuMusicInitialized) return;
                this.isMenuMusicInitialized = true;
                await this.loadSound('menuMusic');
            }

            async initGameSounds() {
                if (this.isGameSoundsInitialized) return;
                if (!this.audioContext) {
                    console.error("AudioContext not initialized. Call initializeAfterInteraction() first.");
                    return;
                }
                this.isGameSoundsInitialized = true;
                
                try {
                    const gameSoundNames = Object.keys(this.soundSources).filter(name => name !== 'menuMusic');
                    await Promise.all(gameSoundNames.map(name => this.loadSound(name)));
                } catch (error) {
                    console.error("One or more game sounds failed to load.", error);
                }
            }

            async loadSound(name) {
                if (!this.audioContext) {
                     throw new Error("AudioContext not initialized. Cannot load sound.");
                }
                if (this.decodedBuffers[name]) {
                    return;
                }

                const fullPath = this.soundSources[name];
                 if (!fullPath) {
                    const error = new Error(`Sound source URL for "${name}" not found.`);
                    console.error(error);
                    throw error;
                }

                try {
                    const response = await fetch(fullPath);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} for ${fullPath}`);
                    }
                    
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('text/html')) {
                        throw new Error(`Server returned a file that looks like HTML instead of an audio file. Check your CDN paths and server configuration. URL: ${fullPath}`);
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.decodedBuffers[name] = audioBuffer;
                } catch (e) {
                    console.error(`Failed to load and decode sound "${name}" from "${fullPath}":`, e);
                    throw e;
                }
            }

            playSound(name, volume = 1.0) {
                if (this.isMuted || !this.decodedBuffers[name] || !this.audioContext) return;

                const source = this.audioContext.createBufferSource();
                source.buffer = this.decodedBuffers[name];
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);

                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                source.start(0);
            }

            playLoopingSound(name, volume = 1.0) {
                if (this.isMuted || !this.decodedBuffers[name] || this.activeLoopingSources[name] || !this.audioContext) return;

                const source = this.audioContext.createBufferSource();
                source.buffer = this.decodedBuffers[name];
                source.loop = true;
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);

                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                source.start(0);
                this.activeLoopingSources[name] = source;
            }

            stopLoopingSound(name) {
                const source = this.activeLoopingSources[name];
                if (source) {
                    try {
                        source.stop(0);
                    } catch (e) {}
                    delete this.activeLoopingSources[name];
                }
            }

            stopAllLoopingSounds() {
                for (const name in this.activeLoopingSources) {
                    this.stopLoopingSound(name);
                }
            }
            
            playMenuMusic() {
                this.playLoopingSound('menuMusic', 0.5);
            }
            
            stopMenuMusic() {
                this.stopLoopingSound('menuMusic');
            }
        }
        const audioManager = new AudioManager();
        // --- End of src/audio.js ---


        // --- Start of src/classes.js ---
        const { canvas, ctx } = UI;

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 40;
                this.size = 15;
                this.speed = 4;
                this.projectileSize = 5;
                this.projectileDamage = 1;
                this.fireRate = 1;
                this.alpha = 1;
                this.allies = [];
                this.lastX = this.x;
                this.isDestroyed = false;
                this.shieldCharges = 0;
            }

            draw() {
                if (this.isDestroyed) return;

                if (this.shieldCharges > 0) {
                    ctx.save();
                    const shieldRadius = this.size * 2.5;
                    const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.5;
                    ctx.fillStyle = `rgba(0, 229, 255, ${pulse})`;
                    ctx.strokeStyle = `rgba(0, 229, 255, 0.8)`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00e5ff';

                    ctx.beginPath();
                    ctx.arc(this.x, this.y + this.size, shieldRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = this.alpha;

                const engineGlow = Math.random() * 0.3 + 0.7;
                ctx.fillStyle = `rgba(0, 229, 255, ${engineGlow})`;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + this.size * 2.2);
                ctx.lineTo(this.x - this.size * 0.6, this.y + this.size * 1.8);
                ctx.lineTo(this.x + this.size * 0.6, this.y + this.size * 1.8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#cccccc';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.size, this.y + this.size * 2);
                ctx.lineTo(this.x, this.y + this.size * 1.5);
                ctx.lineTo(this.x + this.size, this.y + this.size * 2);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            update(game, dt) {
                const moveSpeed = this.speed * 60 * dt;
                if ((game.keys['ArrowLeft'] || game.keys['a']) && this.x > this.size) this.x -= moveSpeed;
                if ((game.keys['ArrowRight'] || game.keys['d']) && this.x < canvas.width - this.size) this.x += moveSpeed;
            }

            shoot(game) {
                if (game.isGameOver || game.isPaused) return;
                audioManager.playSound('shoot', 0.5);
                if (this.fireRate === 2) {
                    game.projectiles.push(new Projectile(this.x - 7, this.y, { size: this.projectileSize, damage: this.projectileDamage }));
                    game.projectiles.push(new Projectile(this.x + 7, this.y, { size: this.projectileSize, damage: this.projectileDamage }));
                } else {
                    game.projectiles.push(new Projectile(this.x, this.y, { size: this.projectileSize, damage: this.projectileDamage }));
                }
            }
        }

        class Projectile {
            constructor(x, y, options = {}) {
                this.x = x;
                this.y = y;
                this.size = options.size ?? 5;
                this.damage = options.damage ?? 1;
                this.vx = options.vx ?? 0;
                this.vy = options.vy ?? -8;
                this.color = options.color ?? '#00ffff';
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y, this.size, this.size * 2);
                ctx.shadowBlur = 0;
            }

            update(game, dt) {
                const moveFactor = 60 * dt;
                this.x += this.vx * moveFactor;
                this.y += this.vy * moveFactor;
            }
        }

        class AIAlly extends Player {
            constructor(side) {
                super();
                this.side = side;
                this.size *= 0.7;
                this.speed = 1; // Retreat speed
                this.projectileSize = 4;
                this.projectileDamage = 1;
                this.fireCooldown = 500;
                this.lastFireTime = 0;
                this.y = canvas.height - 40;
                this.x = side === 'left' ? canvas.width / 4 : canvas.width * 3 / 4;
                this.isRetreating = false;
            }

            draw() {
                if (this.y < -this.size * 2) return;
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.size, this.y + this.size * 2);
                ctx.lineTo(this.x + this.size, this.y + this.size * 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            update(game, dt) {
                if (this.isRetreating) {
                    this.y -= this.speed * 60 * dt;
                    return;
                }

                const patrolCenterX = this.side === 'left' ? canvas.width / 4 : canvas.width * 3 / 4;
                const patrolRange = canvas.width / 5;
                this.x = patrolCenterX + Math.sin(Date.now() / 800) * (patrolRange / 2);
                this.y = canvas.height - 40;

                const fireCooldowns = [500, 450, 400, 350, 320, 300];
                this.fireCooldown = fireCooldowns[game.allyUpgrades.fireRateLevel];

                if (!game.isGameOver && Date.now() - this.lastFireTime > this.fireCooldown) {
                    let bestTarget = null;

                    if (game.isFinalBossActive && game.finalBoss) {
                        const miniBosses = game.asteroids.filter(a => a.isBoss && a !== game.finalBoss);
                        if (miniBosses.length > 0) {
                            bestTarget = miniBosses[0];
                        } else {
                            bestTarget = game.finalBoss;
                        }
                    } else if (game.isBossActive) {
                        bestTarget = game.asteroids.find(a => a.isBoss) ?? null;
                    } else {
                        let minDistance = Infinity;
                        for (const asteroid of game.asteroids) {
                            const isOnCorrectSide = (this.side === 'left' && asteroid.x < canvas.width / 2) ||
                                (this.side === 'right' && asteroid.x >= canvas.width / 2);

                            if (isOnCorrectSide) {
                                const distance = Math.hypot(this.x - asteroid.x, this.y - asteroid.y);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestTarget = asteroid;
                                }
                            }
                        }
                    }

                    if (bestTarget) {
                        this.shootAt(game, bestTarget);
                    }
                    this.lastFireTime = Date.now();
                }
            }

            shootAt(game, target) {
                audioManager.playSound('shoot', 0.2);
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.hypot(dx, dy);
                const baseSpeed = 8;
                const speed = game.allyUpgrades.hasFasterProjectiles ? baseSpeed * 1.5 : baseSpeed;
                const projectileOptions = { size: this.projectileSize, damage: this.projectileDamage };

                if (game.allyUpgrades.hasDoubleShot) {
                    const angle = Math.atan2(dy, dx);
                    const spread = Math.PI / 18;
                    const vx1 = Math.cos(angle - spread) * speed;
                    const vy1 = Math.sin(angle - spread) * speed;
                    const vx2 = Math.cos(angle + spread) * speed;
                    const vy2 = Math.sin(angle + spread) * speed;
                    game.projectiles.push(new Projectile(this.x, this.y, { ...projectileOptions, vx: vx1, vy: vy1 }));
                    game.projectiles.push(new Projectile(this.x, this.y, { ...projectileOptions, vx: vx2, vy: vy2 }));
                } else {
                    const vx = (dx / dist) * speed;
                    const vy = (dy / dist) * speed;
                    game.projectiles.push(new Projectile(this.x, this.y, { ...projectileOptions, vx, vy }));
                }
            }
        }

        class LaserAlly extends Player {
            constructor() {
                super();
                this.size *= 2; // Much larger
                this.x = canvas.width / 2;
                this.y = canvas.height - 70;
                this.isRetreating = false;
                this.isFiring = false;
                this.laserTarget = null;
                this.fireDuration = 10000; // 10s
                this.lastFireStopTime = 0;
                this.cooldownDuration = 15000; // 15s
                this.laserDamage = 20; // Initial Damage Per Second
            }

            draw() {
                if (this.y < -this.size * 2) return;

                const now = Date.now();
                const isOnCooldown = now - this.lastFireStopTime < this.cooldownDuration;
                if (isOnCooldown && !this.isFiring) {
                    ctx.save();
                    const cooldownProgress = (now - this.lastFireStopTime) / this.cooldownDuration;
                    const indicatorRadius = this.size * 0.8;
                    const indicatorX = this.x;
                    const indicatorY = this.y - this.size * 0.5;

                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, indicatorRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = '#00e5ff';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, indicatorRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * cooldownProgress));
                    ctx.stroke();
                    ctx.restore();
                }

                if (this.isFiring && this.laserTarget) {
                    ctx.save();
                    const laserWidth = Math.sin(Date.now() / 50) * 2 + 4;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = laserWidth;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff4500';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.laserTarget.x, this.laserTarget.y);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = '#ffcc00'; // Gold color
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.size, this.y + this.size * 2);
                ctx.lineTo(this.x + this.size, this.y + this.size * 2);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#00e5ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y + this.size * 0.8, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(game, dt) {
                if (this.isRetreating) {
                    this.y -= 1 * 60 * dt;
                    if (this.isFiring) {
                        audioManager.stopLoopingSound('laseringSound');
                        this.isFiring = false;
                    }
                    return;
                }

                this.x = canvas.width / 2; // Keep it centered

                const now = Date.now();
                const isOnCooldown = now - this.lastFireStopTime < this.cooldownDuration;
                let wasFiring = this.isFiring;

                if (this.isFiring) {
                    if (now - (this.lastFireStopTime + this.cooldownDuration) > this.fireDuration) {
                        this.isFiring = false;
                        this.laserTarget = null;
                        this.lastFireStopTime = now;
                    }
                } else if (!isOnCooldown) {
                    this.isFiring = true;
                    this.lastFireStopTime = now - this.cooldownDuration;
                }

                if (this.isFiring && !wasFiring) {
                    audioManager.playLoopingSound('laseringSound', 0.6);
                } else if (!this.isFiring && wasFiring) {
                    audioManager.stopLoopingSound('laseringSound');
                }

                if (this.isFiring) {
                    let bestTarget = null;
                    if (game.isFinalBossActive && game.finalBoss) {
                        bestTarget = game.finalBoss;
                    } else {
                        let minDistance = Infinity;
                        for (const asteroid of game.asteroids) {
                            const distance = Math.hypot(this.x - asteroid.x, this.y - asteroid.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestTarget = asteroid;
                            }
                        }
                    }

                    if (bestTarget) {
                        this.laserTarget = { x: bestTarget.x, y: bestTarget.y };
                        bestTarget.health -= this.laserDamage * dt;
                    } else {
                        this.laserTarget = null;
                    }
                }
            }

            applyUpgrades(game) {
                const damageLevels = [20, 25, 32, 40, 50, 65]; // Damage Per Second
                const cooldownLevels = [15000, 14000, 13000, 11500, 10000, 8000];
                this.laserDamage = damageLevels[game.allyUpgrades.laserDamageLevel];
                this.cooldownDuration = cooldownLevels[game.allyUpgrades.laserCooldownLevel];
            }
        }

        class Asteroid {
            constructor(game, options = {}) {
                this.isBoss = options.isBoss ?? false;
                this.x = options.x ?? Math.random() * canvas.width;
                this.y = options.y ?? -50;
                this.vx = 0;
                this.fireCooldown = 2000;
                this.lastFireTime = Date.now();

                if (this.isBoss) {
                    this.type = 'boss';
                } else if (options.type) {
                    this.type = options.type;
                } else {
                    const rand = Math.random();
                    if (rand < 0.1) this.type = 'scout';
                    else if (rand < 0.2) this.type = 'brute';
                    else if (rand < 0.3) this.type = 'shard';
                    else if (rand < 0.4) this.type = 'shooter';
                    else if (rand < 0.5) this.type = 'splitter';
                    else this.type = 'standard';
                }

                const healthMultiplier = game.gameTime >= 200 ? 2 : 1;

                switch (this.type) {
                    case 'boss':
                        this.size = 60;
                        this.speed = 0.8;
                        this.health = options.healthOverride ?? (50 * healthMultiplier);
                        this.color = '#ff4500';
                        break;
                    case 'scout':
                        this.size = 12;
                        this.speed = Math.random() * 2 + 2.5;
                        this.health = 1 * healthMultiplier;
                        this.color = '#add8e6';
                        break;
                    case 'brute':
                        this.size = 35;
                        this.speed = Math.random() * 1 + 0.8;
                        this.health = 2 * healthMultiplier;
                        this.color = '#d2b48c';
                        break;
                    case 'shard':
                        this.size = 20;
                        this.speed = Math.random() * 1.5 + 1;
                        this.health = 1 * healthMultiplier;
                        this.color = '#dda0dd';
                        this.vx = (Math.random() - 0.5) * 2;
                        break;
                    case 'shooter':
                        this.size = 25;
                        this.speed = Math.random() * 1 + 1;
                        this.health = 2 * healthMultiplier;
                        this.color = '#9400d3';
                        break;
                    case 'splitter':
                        this.size = 30;
                        this.speed = Math.random() * 1 + 1;
                        this.health = 1 * healthMultiplier;
                        this.color = '#ff8c00';
                        break;
                    case 'standard':
                    default:
                        this.size = options.size ?? (Math.random() * 20 + 15);
                        this.speed = Math.random() * 2 + 1;
                        this.health = 1 * healthMultiplier;
                        this.color = '#a9a9a9';
                        break;
                }

                this.shape = [];
                const sides = this.type === 'shard' || this.type === 'shooter' ? 5 : Math.floor(Math.random() * 3) + 7;
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const radius = this.size * (this.type === 'shard' || this.type === 'shooter' ? (i % 2 === 0 ? 1 : 0.5) * (Math.random() * 0.2 + 0.9) : (Math.random() * 0.4 + 0.8));
                    this.shape.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                }
            }

            draw() {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x + this.shape[0].x, this.y + this.shape[0].y);
                for (let i = 1; i < this.shape.length; i++) {
                    ctx.lineTo(this.x + this.shape[i].x, this.y + this.shape[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                if (this.isBoss || this.type === 'brute' || this.type === 'shooter') {
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.ceil(this.health).toString(), this.x, this.y + 5);
                }
            }
            update(game, dt) {
                const moveFactor = 60 * dt;
                this.y += this.speed * moveFactor;
                this.x += this.vx * moveFactor;
                if (this.x < this.size || this.x > canvas.width - this.size) {
                    this.vx *= -1;
                }

                if (this.type === 'shooter' && game.player && !game.isGameOver && Date.now() - this.lastFireTime > this.fireCooldown) {
                    const dx = game.player.x - this.x;
                    const dy = game.player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const speed = 4;
                    const vx = (dx / dist) * speed;
                    const vy = (dy / dist) * speed;
                    game.enemyProjectiles.push(new Projectile(this.x, this.y, { vx, vy, color: '#ff69b4', size: 4 }));
                    audioManager.playSound('enemyShoot', 0.4);
                    this.lastFireTime = Date.now();
                }
            }
        }

        class FinalBoss extends Asteroid {
            constructor(game) {
                super(game, { isBoss: true });
                this.size = 100;
                this.x = canvas.width / 2;
                this.initialY = 120;
                this.y = -this.size; // Start off-screen
                this.isEntering = true;
                this.speed = 1.5;
                this.vx = this.speed;
                this.maxHealth = 1000 * (game.gameTime >= 200 ? 2 : 1);
                this.health = this.maxHealth;
                this.color = '#8b0000';
                this.currentAttack = 'summonMinions';
                this.attackCooldown = 3000;
                this.lastAttackTime = Date.now();
                this.dashTarget = null;
                this.isWarning = false;
                this.warningTime = 0;
                this.isDefeated = false;
                this.isReturning = false;
            }

            draw() {
                if (this.isWarning && this.dashTarget) {
                    ctx.save();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'red';
                    const radius = 40;
                    const pulse = Math.abs(Math.sin(Date.now() / 100));
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(this.dashTarget.x, this.dashTarget.y, radius, 0, Math.PI * 2);
                    ctx.moveTo(this.dashTarget.x - radius, this.dashTarget.y);
                    ctx.lineTo(this.dashTarget.x + radius, this.dashTarget.y);
                    ctx.moveTo(this.dashTarget.x, this.dashTarget.y - radius);
                    ctx.lineTo(this.dashTarget.x, this.dashTarget.y + radius);
                    ctx.stroke();
                    ctx.restore();
                }
                super.draw();
            }

            update(game, dt) {
                const moveFactor = 60 * dt;
                if (this.isEntering) {
                    this.y += 5 * moveFactor; // Entrance speed
                    if (this.y >= this.initialY) {
                        this.y = this.initialY;
                        this.isEntering = false;
                        game.screenShakeDuration = 20;
                        game.screenShakeIntensity = 8;
                        audioManager.playSound('finalbossBegin');
                    }
                    return;
                }

                if (this.isReturning) {
                    const dy = this.initialY - this.y;
                    if (Math.abs(dy) < 5) {
                        this.y = this.initialY;
                        this.isReturning = false;
                    } else {
                        this.y += (dy / Math.abs(dy)) * 5 * moveFactor;
                    }
                    this.x += this.vx * moveFactor;
                    if (this.x < this.size || this.x > canvas.width - this.size) this.vx *= -1;

                } else if (!this.dashTarget) { // Normal patrol
                    this.x += this.vx * moveFactor;
                    if (this.x < this.size || this.x > canvas.width - this.size) {
                        this.vx *= -1;
                    }
                } else { // Dashing
                    if (this.isWarning && Date.now() - this.warningTime > 1200) {
                        this.isWarning = false;
                    } else if (!this.isWarning) {
                        const dx = this.dashTarget.x - this.x;
                        const dy = this.dashTarget.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 20) {
                            this.dashTarget = null;
                            this.isReturning = true;
                            this.vx = this.speed * (Math.random() < 0.5 ? 1 : -1);
                        } else {
                            this.x += (dx / dist) * 20 * moveFactor;
                            this.y += (dy / dist) * 20 * moveFactor;
                        }
                    }
                }

                if (Date.now() - this.lastAttackTime > this.attackCooldown && !this.dashTarget && !this.isReturning) {
                    this.chooseAndPerformAttack(game);
                    this.lastAttackTime = Date.now();
                }
            }

            chooseAndPerformAttack(game) {
                const rand = Math.random();
                if (rand < 0.5) {
                    this.performAttack(game, 'summonMinions');
                    this.attackCooldown = 4000;
                } else if (rand < 0.75) {
                    this.performAttack(game, 'dash');
                    this.attackCooldown = 5000;
                } else if (rand < 0.9) {
                    this.performAttack(game, 'summonCommanders');
                    this.attackCooldown = 8000;
                } else {
                    this.performAttack(game, 'barrage');
                    this.attackCooldown = 6000;
                }
            }

            performAttack(game, attack) {
                switch (attack) {
                    case 'summonMinions':
                        game.updateGameStatus('Boss tri·ªáu h·ªìi qu√°i!');
                        for (let i = 0; i < 5; i++) {
                            game.asteroids.push(new Asteroid(game, { x: this.x + (Math.random() - 0.5) * 100, y: this.y }));
                        }
                        break;
                    case 'summonCommanders':
                        game.updateGameStatus('Boss tri·ªáu h·ªìi ch·ªâ huy!');
                        game.asteroids.push(new Asteroid(game, { isBoss: true, x: this.x - 100, y: this.y, healthOverride: 50 }));
                        game.asteroids.push(new Asteroid(game, { isBoss: true, x: this.x + 100, y: this.y, healthOverride: 50 }));
                        break;
                    case 'dash':
                        game.updateGameStatus('Boss s·∫Øp lao t·ªõi!');
                        this.dashTarget = {
                            x: game.player.x + (Math.random() - 0.5) * 150,
                            y: game.player.y - (Math.random() * 100 + 50)
                        };
                        this.isWarning = true;
                        this.warningTime = Date.now();
                        break;
                    case 'barrage':
                        game.updateGameStatus('Boss b·∫Øn ƒë·∫°n!');
                        audioManager.playSound('enemyShoot', 0.8);
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI;
                            const speed = Math.random() * 2 + 3;
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            game.enemyProjectiles.push(new Projectile(this.x, this.y, { vx, vy, color: '#ff69b4', size: 5 }));
                        }
                        break;
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 3 + 1;
                this.vx = Math.random() * 4 - 2;
                this.vy = Math.random() * 4 - 2;
                this.color = color;
                this.maxLife = Math.random() * 40 + 20;
                this.life = this.maxLife;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(game, dt) {
                const moveFactor = 60 * dt;
                this.x += this.vx * moveFactor;
                this.y += this.vy * moveFactor;
                this.life--;
            }
        }
        // --- End of src/classes.js ---


        // --- Start of src/game.js ---
        class Game {
            constructor() {
                this.animationFrameId = 0;
                this.keys = {};
                this.player = null;
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.asteroids = [];
                this.particles = [];
                this.score = 0;
                this.gameTime = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
                this.nextBossTime = 0;
                this.lastSpawnTime = 0;
                this.nextShieldScore = 0;
                this.upgradePoints = 0;
                this.allyUpgrades = {};
                this.laserAlly = null;
                this.finalBoss = null;
                this.isBossActive = false;
                this.isFinalBossActive = false;
                this.isGameOver = false;
                this.isPaused = false;
                this.isAutoUpgradeEnabled = false;
                this.finalBossWarningShown = false;
                this.finalBossDefeated = false;
                this.screenShakeDuration = 0;
                this.screenShakeIntensity = 0;
                this.flashDuration = 0;
                this.statusMessageTimeout = null;
            }

            start() {
                this.init();
                audioManager.stopAllLoopingSounds();
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
            }

            stop() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = 0;
                }
                audioManager.stopAllLoopingSounds();
                audioManager.playMenuMusic();
            }

            init() {
                this.isGameOver = false;
                this.isPaused = false;
                this.player = new Player();
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.asteroids = [];
                this.particles = [];
                this.score = 0;
                this.gameTime = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
                this.lastSpawnTime = 0;
                this.nextBossTime = 60;
                this.nextShieldScore = 1500;
                this.isBossActive = false;
                this.isFinalBossActive = false;
                this.finalBossWarningShown = false;
                this.finalBossDefeated = false;
                this.finalBoss = null;
                this.laserAlly = null;
                this.upgradePoints = 0;
                this.allyUpgrades = {
                    fireRateLevel: 0,
                    hasDoubleShot: false,
                    hasFasterProjectiles: false,
                    laserDamageLevel: 0,
                    laserCooldownLevel: 0,
                };
                this.screenShakeDuration = 0;
                this.flashDuration = 0;
                if (this.statusMessageTimeout) clearTimeout(this.statusMessageTimeout);
                this.statusMessageTimeout = null;

                this.updateHUD();
                this.updateGameStatus('S·∫µn s√†ng', false);
                UI.finalBossHealthContainer.style.display = 'none';
            }

            gameLoop(currentTime) {
                let deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                if (deltaTime > 0.25) {
                    deltaTime = 0.25;
                }

                if (this.isPaused) {
                    this.animationFrameId = requestAnimationFrame((t) => this.gameLoop(t));
                    return;
                }
                
                this.update(deltaTime);
                this.draw();
                
                this.animationFrameId = requestAnimationFrame((t) => this.gameLoop(t));
            }
            
            update(dt) {
                if (!this.isGameOver) {
                    this.gameTime += dt;
                    this.handleSpawning();
                }

                this.player.update(this, dt);
                this.player.allies.forEach(p => p.update(this, dt));
                if (this.laserAlly) this.laserAlly.update(this, dt);

                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    p.update(this, dt);
                    if (p.y < 0 || p.y > UI.canvas.height || p.x < 0 || p.x > UI.canvas.width) {
                        this.projectiles.splice(i, 1);
                    }
                }
                for (let i = this.enemyProjectiles.length - 1; i >= 0; i--) {
                    const p = this.enemyProjectiles[i];
                    p.update(this, dt);
                    if (p.y < 0 || p.y > UI.canvas.height || p.x < 0 || p.x > UI.canvas.width) {
                        this.enemyProjectiles.splice(i, 1);
                    }
                }
                for (let i = this.asteroids.length - 1; i >= 0; i--) {
                    const a = this.asteroids[i];
                    a.update(this, dt);
                    if (a.y > UI.canvas.height + a.size) {
                        if (a.isBoss && a !== this.finalBoss) {
                            this.isBossActive = false;
                            this.handleGameOver("Boss ƒë√£ tr·ªën tho√°t!");
                            break;
                        } else {
                            this.asteroids.splice(i, 1);
                        }
                    }
                }
                this.particles.forEach((p, i) => { p.update(this, dt); if (p.life <= 0) this.particles.splice(i, 1); });

                if (!this.isGameOver) {
                    this.checkCollisions();
                    for (let j = this.asteroids.length - 1; j >= 0; j--) {
                        const asteroid = this.asteroids[j];
                        if (asteroid.health <= 0) {
                            this.handleAsteroidDestruction(asteroid, j);
                        }
                    }
                    this.updateHUD();
                    this.checkUpgrades();
                }
            }
            
            draw() {
                UI.ctx.save();
                if (this.screenShakeDuration > 0) {
                    const dx = (Math.random() - 0.5) * this.screenShakeIntensity * 2;
                    const dy = (Math.random() - 0.5) * this.screenShakeIntensity * 2;
                    UI.ctx.translate(dx, dy);
                    this.screenShakeDuration--;
                }

                UI.ctx.clearRect(-UI.canvas.width, -UI.canvas.height, UI.canvas.width * 2, UI.canvas.height * 2);

                this.player.draw();
                this.player.allies.forEach(p => p.draw());
                if (this.laserAlly) this.laserAlly.draw();
                this.projectiles.forEach(p => p.draw());
                this.enemyProjectiles.forEach(a => a.draw());
                this.asteroids.forEach(a => a.draw());
                this.particles.forEach(p => p.draw());

                if (this.flashDuration > 0) {
                    UI.ctx.globalAlpha = this.flashDuration / 10;
                    UI.ctx.fillStyle = 'white';
                    UI.ctx.fillRect(-UI.canvas.width, -UI.canvas.height, UI.canvas.width * 2, UI.canvas.height * 2);
                    this.flashDuration--;
                }
                UI.ctx.restore();

                if (this.isFinalBossActive && this.finalBoss) {
                    UI.finalBossHealthBar.style.width = `${Math.max(0, (this.finalBoss.health / this.finalBoss.maxHealth) * 100)}%`;
                }
            }

            handleSpawning() {
                const spawnInterval = Math.max(400, 1200 - Math.floor(this.gameTime) * 10);
                if (performance.now() - this.lastSpawnTime > spawnInterval && !this.isBossActive && !this.isFinalBossActive) {
                    this.asteroids.push(new Asteroid(this));
                    this.lastSpawnTime = performance.now();
                }
                if (this.gameTime >= this.nextBossTime && !this.isBossActive && !this.isFinalBossActive) {
                    this.spawnBoss(false);
                    this.nextBossTime += 60;
                }

                if (this.gameTime >= 295 && !this.finalBossWarningShown) {
                    this.updateGameStatus('!!! C·∫£nh B√°o Boss Cu·ªëi !!!');
                    audioManager.playSound('finalbossWarning');
                    this.finalBossWarningShown = true;
                }

                if (this.gameTime >= 300 && !this.isFinalBossActive && !this.finalBoss && !this.finalBossDefeated) {
                    this.spawnBoss(true);
                }
            }

            spawnBoss(isFinal) {
                if (isFinal) {
                    this.isFinalBossActive = true;
                    this.isBossActive = false;
                    this.asteroids.forEach(a => this.createExplosion(a.x, a.y, a.color, a.size));
                    this.asteroids = [];
                    this.enemyProjectiles = [];
                    this.finalBoss = new FinalBoss(this);
                    this.asteroids.push(this.finalBoss);
                    UI.finalBossHealthContainer.style.display = 'block';
                    this.updateGameStatus('!!! BOSS CU·ªêI XU·∫§T HI·ªÜN !!!');
                    this.screenShakeDuration = 120;
                    this.screenShakeIntensity = 4;
                } else if (!this.isBossActive && !this.isFinalBossActive) {
                    this.asteroids.push(new Asteroid(this, { isBoss: true }));
                    this.isBossActive = true;
                    this.updateGameStatus('Boss xu·∫•t hi·ªán!');
                }
            }


            checkCollisions() {
                for (let j = this.asteroids.length - 1; j >= 0; j--) {
                    if (this.isGameOver) break;
                    const asteroid = this.asteroids[j];
                    if (this.checkCollision(this.player, asteroid)) {
                        if (this.player.shieldCharges > 0) {
                            if (asteroid.isBoss) {
                                this.player.shieldCharges = 0;
                                this.handleGameOver("L√° ch·∫Øn c·ªßa b·∫°n ƒë√£ b·ªã boss ph√° h·ªßy!");
                            } else {
                                this.player.shieldCharges--;
                                this.createExplosion(asteroid.x, asteroid.y, '#00e5ff', 40);
                                this.asteroids.splice(j, 1);
                            }
                        } else {
                            this.handleGameOver("B·∫°n ƒë√£ va ch·∫°m v·ªõi ti·ªÉu h√†nh tinh.");
                        }
                    }
                }

                for (let j = this.enemyProjectiles.length - 1; j >= 0; j--) {
                    const p = this.enemyProjectiles[j];
                    if (this.checkCollision(this.player, p)) {
                        if (this.player.shieldCharges > 0) {
                            this.player.shieldCharges--;
                            this.createExplosion(p.x, p.y, '#00e5ff', 20);
                        } else {
                            this.handleGameOver("B·∫°n b·ªã tr√∫ng ƒë·∫°n.");
                        }
                        this.enemyProjectiles.splice(j, 1);
                        break;
                    }
                }

                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    for (let j = this.asteroids.length - 1; j >= 0; j--) {
                        if (!this.projectiles[i] || !this.asteroids[j]) continue;
                        if (this.checkCollision(this.projectiles[i], this.asteroids[j])) {
                            const asteroid = this.asteroids[j];
                            this.createExplosion(asteroid.x, asteroid.y, asteroid.color);
                            asteroid.health -= this.projectiles[i].damage;
                            this.projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            handleAsteroidDestruction(asteroid, index) {
                if (asteroid === this.finalBoss) {
                    if (this.finalBoss && !this.finalBoss.isDefeated) {
                        audioManager.playSound('finalbossExplosion', 1.0);
                        this.finalBoss.isDefeated = true;
                        this.finalBossDefeated = true;
                        this.score += 5000;
                        this.isFinalBossActive = false;
                        UI.finalBossHealthContainer.style.display = 'none';
                        this.updateGameStatus('BOSS CU·ªêI B·ªä TI√äU DI·ªÜT!');
                        this.upgradePoints += 10;
                        this.player.shieldCharges += 5;
                        this.screenShakeDuration = 60;
                        this.screenShakeIntensity = 20;
                        this.createExplosion(asteroid.x, asteroid.y, asteroid.color, 400);
                        this.asteroids.splice(index, 1);
                        this.finalBoss = null;
                        if (!this.areAllUpgradesMaxed()) {
                            this.isAutoUpgradeEnabled ? this.autoUpgradeAllies() : this.showUpgradeModal();
                        }
                    }
                } else {
                    this.createExplosion(asteroid.x, asteroid.y, asteroid.color, asteroid.size);
                    this.asteroids.splice(index, 1);
                    if (asteroid.isBoss) {
                        this.score += 250;
                        this.isBossActive = false;
                        this.updateGameStatus('Boss b·ªã ti√™u di·ªát!');
                        this.upgradePoints++;
                        if (!this.areAllUpgradesMaxed()) {
                            this.isAutoUpgradeEnabled ? this.autoUpgradeAllies() : this.showUpgradeModal();
                        }
                    } else {
                        audioManager.playSound('enemyDefeated', 0.3);
                        this.score += 10;
                        if (asteroid.type === 'splitter') {
                            this.asteroids.push(new Asteroid(this, { type: 'standard', x: asteroid.x - 10, y: asteroid.y, size: 15 }));
                            this.asteroids.push(new Asteroid(this, { type: 'standard', x: asteroid.x + 10, y: asteroid.y, size: 15 }));
                        }
                    }
                }
                UI.updateUpgradePoints(this.upgradePoints);
            }

            handleGameOver(reason) {
                if (this.isGameOver) return;
                this.isGameOver = true;
                
                audioManager.playSound('PlayerDead');
                audioManager.stopAllLoopingSounds();
                audioManager.playMenuMusic();

                this.player.isDestroyed = true;
                this.player.allies.forEach(ally => ally.isRetreating = true);
                if (this.laserAlly) this.laserAlly.isRetreating = true;

                this.screenShakeDuration = 30;
                this.screenShakeIntensity = 10;
                this.flashDuration = 10;
                this.createExplosion(this.player.x, this.player.y, '#ff4500', 100);

                this.updateGameStatus("K·∫øt th√∫c!", false);
                UI.showMessage("Tr√≤ ch∆°i k·∫øt th√∫c!", `${reason} ƒêi·ªÉm c·ªßa b·∫°n: ${this.score}`);
            }

            checkCollision(obj1, obj2) {
                if (!obj1 || !obj2 || (obj1 instanceof Player && obj1.isDestroyed)) return false;
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                const distance = Math.hypot(dx, dy);
                const collisionDistance = (obj1.size + obj2.size) * 0.8;
                return distance < collisionDistance;
            }

            createExplosion(x, y, color, count = 20) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            triggerAllyUpgradeEffect(ally) {
                this.createExplosion(ally.x, ally.y, '#ffd700', 30);
            }

            checkUpgrades() {
                if (this.score >= 250 && this.player.projectileSize < 7) {
                    this.player.projectileSize = 7;
                    this.player.projectileDamage = 2;
                    this.updateGameStatus('N√¢ng c·∫•p! ƒê·∫°n to h∆°n!');
                    audioManager.playSound('Playerupgraded');
                }
                if (this.score >= 500 && this.player.fireRate < 2) {
                    this.player.fireRate = 2;
                    this.updateGameStatus('N√¢ng c·∫•p! B·∫Øn 2 vi√™n!');
                    audioManager.playSound('Playerupgraded');
                }
                if (this.score >= 2000 && this.player.allies.length === 0) {
                    this.player.allies.push(new AIAlly('left'));
                    this.player.allies.push(new AIAlly('right'));
                    this.updateGameStatus('N√¢ng c·∫•p! ƒê·ªìng minh AI!');
                    audioManager.playSound('Playerupgraded', 0.8);
                }
                if (this.score >= 5000 && !this.laserAlly) {
                    this.laserAlly = new LaserAlly();
                    this.laserAlly.applyUpgrades(this);
                    this.updateGameStatus('ƒê·ªìng minh Laser ƒë√£ tham chi·∫øn!');
                    audioManager.playSound('Playerupgraded', 0.8);
                }
                if (this.score >= this.nextShieldScore) {
                    this.player.shieldCharges += 3;
                    this.nextShieldScore += 1500;
                    this.updateGameStatus('Khi√™n ƒë√£ ƒë∆∞·ª£c s·∫°c!');
                    audioManager.playSound('Playerupgraded');
                }
            }

            updateHUD() {
                UI.scoreDisplay.innerText = `${this.score}`;
                UI.shieldDisplay.innerText = `${this.player.shieldCharges}`;
                UI.timerDisplay.innerText = `${Math.floor(this.gameTime)}s`;
                UI.updateUpgradePoints(this.upgradePoints);
            }

            updateGameStatus(text, autoFade = true) {
                if (this.statusMessageTimeout) {
                    clearTimeout(this.statusMessageTimeout);
                }
                UI.gameStatus.innerText = text;
                UI.gameStatus.style.opacity = '1';

                if (autoFade) {
                    this.statusMessageTimeout = setTimeout(() => {
                        UI.gameStatus.style.opacity = '0';
                    }, 2500);
                }
            }

            resizeCanvas() {
                UI.canvas.width = window.innerWidth;
                UI.canvas.height = window.innerHeight - 50;
                if (this.player) {
                    this.player.x = Math.max(this.player.size, Math.min(UI.canvas.width - this.player.size, this.player.x));
                }
            }

            showUpgradeModal() {
                this.isPaused = true;
                this.updateUpgradeModalUI();
                UI.upgradeModal.classList.add('visible');
            }

            hideUpgradeModal() {
                UI.upgradeModal.classList.remove('visible');
                this.isPaused = false;
                this.lastTime = performance.now();
                this.lastSpawnTime = performance.now();
            }
            
            updateUpgradeModalUI() {
                UI.updateUpgradeModal(this.upgradePoints, this.allyUpgrades, !!this.laserAlly);
            }

            areAllUpgradesMaxed() {
                return this.allyUpgrades.fireRateLevel >= 5 &&
                       this.allyUpgrades.hasDoubleShot &&
                       this.allyUpgrades.hasFasterProjectiles &&
                       (!this.laserAlly || (this.allyUpgrades.laserDamageLevel >= 5 && this.allyUpgrades.laserCooldownLevel >= 5));
            }
            
            autoUpgradeAllies() {
                while (this.upgradePoints > 0 && !this.areAllUpgradesMaxed()) {
                     if (this.allyUpgrades.fireRateLevel < 5 && this.upgradePoints >= 1) {
                        this.upgradeAlly('firerate');
                    } else if (!this.allyUpgrades.hasDoubleShot && this.upgradePoints >= 1) {
                        this.upgradeAlly('doubleshot');
                    } else if (!this.allyUpgrades.hasFasterProjectiles && this.upgradePoints >= 1) {
                        this.upgradeAlly('projectilespeed');
                    } else if (this.laserAlly && this.allyUpgrades.laserDamageLevel < 5 && this.upgradePoints >= 3) {
                        this.upgradeAlly('laserDamage');
                    } else if (this.laserAlly && this.allyUpgrades.laserCooldownLevel < 5 && this.upgradePoints >= 4) {
                         this.upgradeAlly('laserCooldown');
                    } else {
                        break;
                    }
                }
            }
            
            upgradeAlly(type) {
                let cost = 0;
                let upgraded = false;
                switch (type) {
                    case 'firerate': cost = 1; if (this.allyUpgrades.fireRateLevel < 5 && this.upgradePoints >= cost) { this.upgradePoints -= cost; this.allyUpgrades.fireRateLevel++; upgraded = true;} break;
                    case 'doubleshot': cost = 1; if (!this.allyUpgrades.hasDoubleShot && this.upgradePoints >= cost) { this.upgradePoints -= cost; this.allyUpgrades.hasDoubleShot = true; upgraded = true;} break;
                    case 'projectilespeed': cost = 1; if (!this.allyUpgrades.hasFasterProjectiles && this.upgradePoints >= cost) { this.upgradePoints -= cost; this.allyUpgrades.hasFasterProjectiles = true; upgraded = true;} break;
                    case 'laserDamage': cost = 3; if (this.laserAlly && this.allyUpgrades.laserDamageLevel < 5 && this.upgradePoints >= cost) { this.upgradePoints -= cost; this.allyUpgrades.laserDamageLevel++; upgraded = true;} break;
                    case 'laserCooldown': cost = 4; if (this.laserAlly && this.allyUpgrades.laserCooldownLevel < 5 && this.upgradePoints >= cost) { this.upgradePoints -= cost; this.allyUpgrades.laserCooldownLevel++; upgraded = true;} break;
                }

                if (upgraded) {
                     audioManager.playSound('AIupgraded');
                }

                if (type.startsWith('laser')) {
                    if (this.laserAlly) { this.laserAlly.applyUpgrades(this); this.triggerAllyUpgradeEffect(this.laserAlly); }
                } else {
                    this.player.allies.forEach(ally => this.triggerAllyUpgradeEffect(ally));
                }
            }
        }
        // --- End of src/game.js ---


        // --- Start of index.js ---
        window.addEventListener('DOMContentLoaded', () => {
            const game = new Game();

            const playMenuMusicOnFirstInteraction = async () => {
                await audioManager.initializeAfterInteraction();
                await audioManager.initMenuMusic();
                audioManager.playMenuMusic();
                document.body.removeEventListener('click', playMenuMusicOnFirstInteraction);
                document.body.removeEventListener('keydown', playMenuMusicOnFirstInteraction);
            };
            document.body.addEventListener('click', playMenuMusicOnFirstInteraction, { once: true });
            document.body.addEventListener('keydown', playMenuMusicOnFirstInteraction, { once: true });


            UI.playButton.addEventListener('click', async () => {
                await audioManager.initializeAfterInteraction();
                audioManager.stopMenuMusic();
                UI.mainContainer.classList.add('hidden');
                UI.loadingContainer.classList.add('visible');
                
                await audioManager.initGameSounds();

                UI.loadingContainer.classList.remove('visible');
                UI.gameArea.classList.add('visible');

                UI.gameArea.addEventListener('transitionend', () => {
                    UI.gameArea.classList.add('fullscreen-game');
                    game.resizeCanvas();
                    game.start();
                }, { once: true });
            });

            UI.messageButton.addEventListener('click', () => {
                UI.hideMessage(() => {
                    game.start();
                });
            });

            UI.backToMenuButton.addEventListener('click', () => {
                UI.hideMessage(() => {
                    game.stop();
                    game.init();
                    UI.gameArea.classList.remove('fullscreen-game');
                    
                    UI.gameArea.addEventListener('transitionend', () => {
                        UI.gameArea.classList.remove('visible');
                        UI.mainContainer.classList.remove('hidden');
                    }, { once: true });
                });
            });

            UI.howToPlayButton.addEventListener('click', () => {
                UI.howToPlayModal.classList.add('visible');
            });

            UI.closeHowToPlayButton.addEventListener('click', () => {
                UI.howToPlayModal.classList.remove('visible');
            });

            window.addEventListener('resize', () => {
                if (UI.gameArea.classList.contains('fullscreen-game')) {
                    game.resizeCanvas();
                }
            });

            window.addEventListener('keydown', (e) => { game.keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { game.keys[e.key] = false; });

            let shootInterval = null;
            const startShooting = () => {
                if (!shootInterval && game.player) {
                    game.player.shoot(game);
                    shootInterval = setInterval(() => game.player?.shoot(game), 200);
                }
            };
            const stopShooting = () => {
                if (shootInterval !== null) {
                    clearInterval(shootInterval);
                    shootInterval = null;
                }
            };

            UI.canvas.addEventListener('mousedown', startShooting);
            UI.canvas.addEventListener('mouseup', stopShooting);
            UI.canvas.addEventListener('mouseleave', stopShooting);

            function handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length > 0 && game.player) {
                    const touch = e.touches[0];
                    const rect = UI.canvas.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    game.player.x = Math.max(game.player.size, Math.min(UI.canvas.width - game.player.size, touchX));
                }
            }

            UI.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startShooting();
                if (e.touches.length > 0) {
                    handleTouchMove(e);
                    UI.canvas.addEventListener('touchmove', handleTouchMove);
                }
            });

            UI.canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopShooting();
                UI.canvas.removeEventListener('touchmove', handleTouchMove);
            });
            
            UI.continueButton.addEventListener('click', () => game.hideUpgradeModal());
            UI.upgradeFirerateBtn.addEventListener('click', () => {
                game.upgradeAlly('firerate');
                game.updateUpgradeModalUI();
            });
            UI.upgradeDoubleshotBtn.addEventListener('click', () => {
                game.upgradeAlly('doubleshot');
                game.updateUpgradeModalUI();
            });
            UI.upgradeProjectilespeedBtn.addEventListener('click', () => {
                game.upgradeAlly('projectilespeed');
                game.updateUpgradeModalUI();
            });
            UI.upgradeLaserDamageBtn.addEventListener('click', () => {
                game.upgradeAlly('laserDamage');
                game.updateUpgradeModalUI();
            });
            UI.upgradeLaserCooldownBtn.addEventListener('click', () => {
                game.upgradeAlly('laserCooldown');
                game.updateUpgradeModalUI();
            });
            UI.autoUpgradeCheckbox.addEventListener('change', () => {
                game.isAutoUpgradeEnabled = UI.autoUpgradeCheckbox.checked;
            });
        });
        // --- End of index.js ---

    })();
    </script>
</body>
</html>